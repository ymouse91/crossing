<!DOCTYPE html>
<html lang="fi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>River Crossing (PWA-demo)</title>
  <meta name="theme-color" content="#0d6efd">
  <style>
    :root{
      --bg:#0f172a; --ink:#e5e7eb; --muted:#94a3b8; --accent:#0d6efd; --good:#22c55e; --bad:#ef4444;
      --board:#2f3947; --water:#1b221b; --bank:#2f3947; --plank:#f5deb3; --plank2:#f3c98b; --plank3:#e0a458;
      --cell:84; /* svg unit px per grid cell */
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; background:linear-gradient(180deg,#0b1021,#0f1429 40%,#0b1021);
      color:var(--ink); font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, sans-serif;
      display:grid; grid-template-rows:auto auto 1fr; gap:12px; place-items:center; padding: max(env(safe-area-inset-top),14px) 10px max(env(safe-area-inset-bottom),16px);
    }
    header{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; justify-content:center }
    h1{margin:0; font-size:20px; letter-spacing:.2px}
    .meta{font-size:12px; color:var(--muted)}
    .hud{display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:center}
    button{background:var(--accent); color:white; border:0; padding:10px 14px; border-radius:12px; font-weight:700; cursor:pointer; box-shadow:0 4px 10px rgba(0,0,0,.25)}
    button.ghost{ background:#25324a; color:#cbd5e1 }
    button:disabled{ opacity:.6; cursor:not-allowed }
    .pill{ padding:6px 10px; border-radius:999px; background:#1e293b; color:#cbd5e1; font-size:12px }
    .wrap{ display:grid; gap:10px; place-items:center }
    svg{ width:min(96vw, calc(var(--cell)*5px + 24px)); height:auto; border-radius:16px; box-shadow: 0 12px 40px rgba(0,0,0,.35)}
    select{ background:#1e293b; color:#cbd5e1; border:1px solid #334155; border-radius:10px; padding:8px 10px; font-weight:700 }
  </style>
</head>
<body>
  <header>
    <h1>River Crossing</h1>
    <span class="meta" id="today" style="display:none;"></span>
  </header>

  <!-- Vain valinta + seuraava -->
  <div class="hud">
    <label>Valitse pulma:
      <select id="puzzleSel"></select>
    </label>
    <button id="openSelected">Avaa</button>
    <button id="next">Seuraava</button>
    <button id="reset" class="ghost">Palauta</button>
    <span class="pill">Siirrot: <b id="moves">0</b></span>
    <span class="pill" style="display:none;">Kantoon: <span class="carry" id="carry">–</span></span>
    <span class="pill" style="display:none;">Aloitus: <b id="startLbl">–</b>, Maali: <b id="goalLbl">–</b></span>
  </div>

  <div class="wrap">
    <!-- SVG pelilauta -->
    <svg id="board" viewBox="0 0 500 640" aria-label="River Crossing board"></svg>
  </div>

<script>
/* =====================
   PWA manifest + SW (yhteen tiedostoon)
   ===================== */
(function(){
  const manifest = {
    name: "River Crossing",
    short_name: "Crossing",
    start_url: "./",
    display: "standalone",
    background_color: "#0b1021",
    theme_color: "#0d6efd",
    icons: [
      { src: "data:image/svg+xml;utf8,<?xml version='1.0' encoding='UTF-8'?>\n<svg xmlns='http://www.w3.org/2000/svg' width='512' height='512' viewBox='0 0 512 512'><rect width='512' height='512' fill='%230b1021'/><rect x='32' y='96' width='448' height='64' rx='12' fill='%231f2937'/><rect x='32' y='352' width='448' height='64' rx='12' fill='%231f2937'/><g stroke='%23a7f3d0' stroke-width='12'>{grid}</g><g stroke='%23f3c98b' stroke-width='24' stroke-linecap='round'><line x1='96' y1='192' x2='416' y2='192'/><line x1='96' y1='272' x2='320' y2='272'/><line x1='192' y1='352' x2='416' y2='352'/></g><circle cx='96' cy='192' r='18' fill='%2338bdf8'/></svg>", sizes:"512x512", type:"image/svg+xml"}
    ]
  };
  manifest.icons[0].src = manifest.icons[0].src.replace('{grid}', Array.from({length:6},(_,i)=>`<line x1='${96+i*64}' y1='160' x2='${96+i*64}' y2='416'/>`).join(''));
  const blob = new Blob([JSON.stringify(manifest)], {type:'application/json'});
  const link = document.createElement('link');
  link.rel = 'manifest'; link.href = URL.createObjectURL(blob);
  document.head.appendChild(link);

  if('serviceWorker' in navigator && !location.href.startsWith('blob:') && !location.href.startsWith('data:')){
    const swCode = `self.addEventListener('install',e=>{self.skipWaiting(); e.waitUntil(caches.open('rc-v1').then(c=>c.addAll(['./','./puzzles_7x5.json'])))})\nself.addEventListener('activate',e=>self.clients.claim());\nself.addEventListener('fetch',e=>{e.respondWith(caches.match(e.request).then(r=>r||fetch(e.request)))})`;
    const swBlob = new Blob([swCode], {type:'text/javascript'});
    const swUrl = URL.createObjectURL(swBlob);
    navigator.serviceWorker.register(swUrl).catch(()=>{});
  }
})();
</script>

<script>
// =====================
// River Crossing – pelilogiikka (5×5, pankit molemmissa päissä)
// =====================
const CELL = 84; // px per unit (svg scale)
const W = 5, H = 5; // grid koko (0..4), pankit: y=-1 ja y=H
const board = document.getElementById('board');
const movesEl = document.getElementById('moves');
const carryEl = document.getElementById('carry');
const startLbl = document.getElementById('startLbl');
const goalLbl  = document.getElementById('goalLbl');
const todayEl  = document.getElementById('today');

// Pelin UI
const puzzleSel   = document.getElementById('puzzleSel');
const openBtn     = document.getElementById('openSelected');
const nextBtn     = document.getElementById('next');

// Päivämäärä
(function(){
  const d = new Date();
  const fmt = d.toLocaleDateString('fi-FI', { weekday:'short', year:'numeric', month:'2-digit', day:'2-digit' });
  todayEl.textContent = ` – ${fmt}`;
})();

// Pelitila
const state = {
  stumps: [],           // [{x,y}]  (y -1..H)
  planks: [],           // [{len, x,y, dir:'h'|'v'}]
  hiker: { pos:'bank', row:-1, col:2 },
  carrying: 0,
  start: { side:'top', col:2 },
  goal:  { side:'bottom', col:2 },
  moves: 0,
  frozen: false,
  snapshot: null
};

// Ladatut pulmat muistissa
let loadedPuzzles = [];
let loadedIndex = -1;

// ====== Apufunktiot ======
function toast(msg, t=1500){ const d=document.createElement('div'); d.textContent=msg; d.className='pill'; d.style.position='fixed'; d.style.bottom='16px'; d.style.left='50%'; d.style.transform='translateX(-50%)'; d.style.background='#0f172a'; d.style.border='1px solid #334155'; d.style.padding='8px 10px'; d.style.zIndex='9999'; document.body.appendChild(d); setTimeout(()=>d.remove(), t); }
function svg(tag, attrs={}){ const el = document.createElementNS('http://www.w3.org/2000/svg', tag); for(const k in attrs) el.setAttribute(k, attrs[k]); return el; }
function rect(x,y,w,h,attrs={}){ return svg('rect', Object.assign({x,y,width:w,height:h}, attrs)); }
function line(x1,y1,x2,y2,attrs={}){ return svg('line', Object.assign({x1,y1,x2,y2}, attrs)); }
function circle(cx,cy,r,attrs={}){ return svg('circle', Object.assign({cx,cy,r}, attrs)); }

function stumpAt(x,y){
  if(state.stumps.some(s=>s.x===x && s.y===y)) return true;
  if(y===-1 && x===state.start.col) return true;
  if(y===H  && x===state.goal.col)  return true;
  return false;
}
function inBounds(x,y){ return x>=0 && x<W && y>=0 && y<H; }
function plankEndpoints(p){
  const dx = p.dir==='h'?1:0, dy = p.dir==='v'?1:0;
  return [ {x:p.x, y:p.y}, {x:p.x + dx*p.len, y:p.y + dy*p.len} ];
}
function neighborsFrom(x,y){
  const adj = [];
  for(const p of state.planks){
    const [a,b] = plankEndpoints(p);
    if(a.x===x && a.y===y) adj.push(b);
    else if(b.x===x && b.y===y) adj.push(a);
  }
  return adj;
}
function atBankTop(){ return state.hiker.pos==='bank' && state.hiker.row===-1; }
function atBankBottom(){ return state.hiker.pos==='bank' && state.hiker.row===H; }
function canEnterGridFromBank(){
  if(atBankTop())    return neighborsFrom(state.hiker.col, -1).length>0;
  if(atBankBottom()) return neighborsFrom(state.hiker.col, H).length>0;
  return false;
}
function reachedGoal(){
  if(state.goal.side==='bottom'){
    return state.hiker.pos==='bank' && state.hiker.row===H && state.hiker.col===state.goal.col;
  } else {
    return state.hiker.pos==='bank' && state.hiker.row===-1 && state.hiker.col===state.goal.col;
  }
}

// ====== Sijoitusvalidointi (EI tolpan yli, EI ristiin, EI limitys) ======
function segmentsOverlap(a1,a2,b1,b2){
  // avustus: tarkista avoin väli [min,max] leikkautuuko >0 pituudelta (ei pelkkää päätepistettä)
  const minA = Math.min(a1,a2), maxA = Math.max(a1,a2);
  const minB = Math.min(b1,b2), maxB = Math.max(b1,b2);
  const left = Math.max(minA, minB), right = Math.min(maxA, maxB);
  return (right - left) > 0; // tiukasti positiivinen
}
function crossesExisting(newP){
  const [na, nb] = plankEndpoints(newP);
  for(const q of state.planks){
    const [qa, qb] = plankEndpoints(q);

    // 1) Ristiin menevä (h vs v): sisäleikkaus ei saa tapahtua
    if(newP.dir !== q.dir){
      const h = newP.dir==='h' ? newP : q;
      const v = newP.dir==='v' ? newP : q;
      const [ha,hb] = plankEndpoints(h);
      const [va,vb] = plankEndpoints(v);
      const x = va.x;                    // v:n x on vakio
      const y = ha.y;                    // h:n y on vakio
      const onX = x > Math.min(ha.x,hb.x) && x < Math.max(ha.x,hb.x);
      const onY = y > Math.min(va.y,vb.y) && y < Math.max(va.y,vb.y);
      if(onX && onY) return true;        // sisäleikkaus -> kielletty
    }else{
      // 2) Saman suuntaiset: limitys samalla linjalla kielletty, sallitaan vain täsmälleen yhteinen päätepiste
      if(newP.dir==='h' && na.y===qa.y){
        if(segmentsOverlap(na.x, nb.x, qa.x, qb.x)) return true;
      }
      if(newP.dir==='v' && na.x===qa.x){
        if(segmentsOverlap(na.y, nb.y, qa.y, qb.y)) return true;
      }
    }
  }
  return false;
}
function passesOverStump(newP){
  const [a,b] = plankEndpoints(newP);
  if(newP.dir==='h'){
    const y = a.y;
    const x0 = Math.min(a.x,b.x), x1 = Math.max(a.x,b.x);
    for(let x=x0+1; x<=x1-1; x++){          // vain välipisteet
      if(stumpAt(x,y)) return true;
    }
  }else{
    const x = a.x;
    const y0 = Math.min(a.y,b.y), y1 = Math.max(a.y,b.y);
    for(let y=y0+1; y<=y1-1; y++){
      if(stumpAt(x,y)) return true;
    }
  }
  return false;
}
function canPlacePlank(len, sx, sy, tx, ty){
  const dx = tx - sx, dy = ty - sy;
  if(dx!==0 && dy!==0) return false;
  const dist = Math.abs(dx)+Math.abs(dy);
  if(dist!==len) return false;
  const dir = (dy===0)?'h':'v';
  const newP = {len, x:Math.min(sx,tx), y:Math.min(sy,ty), dir};
  if(passesOverStump(newP)) return false;
  if(crossesExisting(newP)) return false;
  return true;
}

// ====== Renderöinti (SVG) ======
function render(){
  const pad = 24;
  const width = W*CELL + pad*2, height = (H+2)*CELL + pad*2;
  board.setAttribute('viewBox', `0 0 ${width} ${height}`);
  board.innerHTML = '';

  // Vesi ja pankit
  const gBg = svg('g');
  gBg.appendChild(rect(pad, pad+CELL*1, W*CELL, H*CELL, {fill:'var(--water)', rx:16}));
  gBg.appendChild(rect(pad, pad, W*CELL, CELL, {fill:'var(--bank)', rx:12}));
  gBg.appendChild(rect(pad, pad+CELL*(H+1), W*CELL, CELL, {fill:'var(--bank)', rx:12}));
  board.appendChild(gBg);

  // Ruudukko
  const grid = svg('g', {stroke:'#1f2937', 'stroke-width':2});
  for(let x=0;x<=W;x++) grid.appendChild(line(pad+x*CELL, pad+CELL, pad+x*CELL, pad+CELL*(H+1)));
  for(let y=1;y<=H+1;y++) grid.appendChild(line(pad, pad+y*CELL, pad+W*CELL, pad+y*CELL));
  board.appendChild(grid);

  // Lankut
  const gPlank = svg('g', {'stroke':'#00000022', 'stroke-width':1});
  for(const p of state.planks){
    const [a,b] = plankEndpoints(p);
    const x1 = pad + a.x*CELL + CELL/2; const y1 = pad + (a.y+1)*CELL + CELL/2;
    const x2 = pad + b.x*CELL + CELL/2; const y2 = pad + (b.y+1)*CELL + CELL/2;
    const len = Math.hypot(x2-x1,y2-y1);
    const ang = Math.atan2(y2-y1,x2-x1)*180/Math.PI;
    const thickness = 20;
    const g = svg('g', {transform:`translate(${x1} ${y1}) rotate(${ang})`});
    const fill = p.len===1?'var(--plank)':(p.len===2?'var(--plank2)':'var(--plank3)');
    const r = svg('rect', {x:0, y:-thickness/2, width:len, height:thickness, fill, rx:10});
    g.appendChild(r);
    g.appendChild(circle(0,0,6,{fill:'#00000033'}));
    g.appendChild(circle(len,0,6,{fill:'#00000033'}));
    g.style.cursor = 'pointer';
    g.addEventListener('click', ()=>onPlankClick(p));
    gPlank.appendChild(g);
  }
  board.appendChild(gPlank);

  // Tolpat
  const gSt = svg('g');
  for(const s of state.stumps){
    const cx = pad + s.x*CELL + CELL/2;
    const cy = pad + (s.y+1)*CELL + CELL/2;
    const c = circle(cx, cy, 10, {fill:'#a7f3d0', stroke:'#072', 'stroke-width':1});
    c.style.cursor = 'pointer';
    c.addEventListener('click', ()=>onStumpClick(s.x,s.y));
    gSt.appendChild(c);
  }
  board.appendChild(gSt);

  // Pankkien klikattavat alueet + START/GOAL pisteet
  const gMarks = svg('g');

  const topY = pad + CELL/2;
  const botY = pad + (H+1.5)*CELL;

  // Klikattavat hot-alueet
  const topHot = rect(pad, pad, W*CELL, CELL, {fill:'transparent'});
  const botHot = rect(pad, pad + CELL*(H+1), W*CELL, CELL, {fill:'transparent'});
  topHot.style.cursor = 'pointer';
  botHot.style.cursor = 'pointer';
  topHot.addEventListener('click', ()=>onBankClick('top'));
  botHot.addEventListener('click', ()=>onBankClick('bottom'));
  gMarks.appendChild(topHot);
  gMarks.appendChild(botHot);

  // Start (vihreä) oikealle pankille
  const startX = pad + state.start.col*CELL + CELL/2;
  const startY = (state.start.side==='top') ? topY : botY;
  const startDot = circle(startX, startY, 16, {fill:'#16a34a', stroke:'#064e3b', 'stroke-width':2});
  startDot.style.cursor = 'pointer';
  startDot.addEventListener('click', ()=>onBankClick(state.start.side));
  gMarks.appendChild(startDot);

  // Goal (punainen) oikealle pankille
  const goalX = pad + state.goal.col*CELL + CELL/2;
  const goalY = (state.goal.side==='bottom') ? botY : topY;
  const goalDot = circle(goalX, goalY, 16, {fill:'#dc2626', stroke:'#7f1d1d', 'stroke-width':2});
  goalDot.style.cursor = 'pointer';
  goalDot.addEventListener('click', ()=>onBankClick(state.goal.side));
  gMarks.appendChild(goalDot);

  board.appendChild(gMarks);

  // Hiker PIIRRETÄÄN VIIMEISEKSI -> aina päällimmäisenä
  const gH = svg('g');
  if(state.hiker.pos==='stump'){
    const cx = pad + state.hiker.x*CELL + CELL/2;
    const cy = pad + (state.hiker.y+1)*CELL + CELL/2;
    gH.appendChild(circle(cx, cy, 16, {fill:'#38bdf8', stroke:'#083344', 'stroke-width':2}));
  } else {
    const y = state.hiker.row<0 ? pad+CELL/2 : pad+(H+1.5)*CELL;
    const x = pad + state.hiker.col*CELL + CELL/2;
    gH.appendChild(circle(x, y, 16, {fill:'#38bdf8', stroke:'#083344', 'stroke-width':2}));
  }
  board.appendChild(gH);

  // HUD
  movesEl.textContent = state.moves;
  carryEl.textContent = state.carrying? `${state.carrying} yk.` : '–';
  startLbl.textContent = `${state.start.side==='top'?'Ylä':'Ala'} pankki, sarake ${state.start.col+1}`;
  goalLbl.textContent  = `${state.goal .side==='bottom'?'Ala':'Ylä'} pankki, sarake ${state.goal.col+1}`;
}

// ====== Interaktio ======

function bankCol(side){
  if(side === 'top'){
    return (state.start.side === 'top') ? state.start.col : state.goal.col;
  }else{ // 'bottom'
    return (state.start.side === 'bottom') ? state.start.col : state.goal.col;
  }
}

function onBankClick(side){
  if(state.frozen) return;
  const isTop = side==='top';
  const bankY = isTop ? -1 : H;
  const col   = bankCol(side);

  // Pudota kannettava lankku pankkiin, jos pituus täsmää ja reitti on vapaa (ei risteä/ylitä tolppaa)
  if(state.carrying && state.hiker.pos==='stump' && state.hiker.x===col){
    const sy = state.hiker.y;
    const targetLen = Math.abs(bankY - sy);
    if(targetLen===state.carrying){
      const tx = col, ty = bankY;
      if(canPlacePlank(state.carrying, state.hiker.x, state.hiker.y, tx, ty)){
        const startY = Math.min(sy, bankY);
        state.planks.push({len:state.carrying, x:col, y:startY, dir:'v'});
        state.carrying = 0;
        state.moves++;
        render();
        return;
      }
    }
  }

  // Siirtyminen tolpasta pankkiin, jos lankku johtaa pankkiin
  if(state.hiker.pos==='stump' && state.hiker.x===col){
    const adj = neighborsFrom(state.hiker.x, state.hiker.y);
    if(adj.some(p=>p.x===col && p.y===bankY)){
      state.hiker = {pos:'bank', row:bankY, col};
      state.moves++;
      checkWin();
      render();
      return;
    }
  }

  // Pankista ruudukkoon (jos pankista lähtee lankku)
  const atThisBank = state.hiker.pos==='bank' && state.hiker.row===bankY;
  if(atThisBank){
    const opts = neighborsFrom(col, bankY);
    if(opts.length){
      const p = opts[0];
      state.hiker = {pos:'stump', x:p.x, y:p.y};
      state.moves++;
      render();
      return;
    }
  }
}

function onStumpClick(x,y){
  if(state.frozen) return;
  if(state.hiker.pos==='stump'){
    const adj = neighborsFrom(state.hiker.x, state.hiker.y);
    if(adj.some(p=>p.x===x && p.y===y)){
      state.hiker.x=x; state.hiker.y=y; state.moves++;
      checkWin(); render(); return;
    }
  } else if(atBankTop() && x===state.hiker.col && canEnterGridFromBank()){
    const opts = neighborsFrom(state.hiker.col, -1);
    if(opts.some(p=>p.x===x && p.y===y)){
      state.hiker={pos:'stump', x, y}; state.moves++; render(); return;
    }
  } else if(atBankBottom() && x===state.hiker.col && canEnterGridFromBank()){
    const opts = neighborsFrom(state.hiker.col, H);
    if(opts.some(p=>p.x===x && p.y===y)){
      state.hiker={pos:'stump', x, y}; state.moves++; render(); return;
    }
  }

  // Aseta lankku (kantona)
  if(state.carrying && state.hiker.pos==='stump'){
    const sx = state.hiker.x, sy = state.hiker.y;
    const dx = x - sx, dy = y - sy;
    const len = state.carrying;
    if(canPlacePlank(len, sx, sy, x, y)){
      const dir = (dy===0)?'h':'v';
      const ox = Math.min(sx,x), oy = Math.min(sy,y);
      state.planks.push({len, x:ox, y:oy, dir});
      state.carrying = 0; state.moves++; render();
    }
  }
}
function onPlankClick(p){
  if(state.frozen) return;
  if(state.carrying) return;
  const [a,b] = plankEndpoints(p);
  if(state.hiker.pos==='stump' && ((state.hiker.x===a.x && state.hiker.y===a.y) || (state.hiker.x===b.x && state.hiker.y===b.y))){
    state.carrying = p.len;
    state.planks = state.planks.filter(q=>q!==p);
    state.moves++;
    render();
  }
}

function checkWin(){
  if(reachedGoal()){
    state.frozen = true;
    setTimeout(()=>alert(`Onnittelut! Pääsit maaliin ${state.moves} siirrolla.`), 10);
  }
}

// ====== Editorin JSON → Pelitila
// Editoriformaatti: rows=7, cols=5, rannat r=0 (ylä) ja r=6 (ala); vesi 1..5.
// start/goal {r,c}; poles [{r,c}], planks [[r1,c1,r2,c2],...]
// Huom! Start ja Goal voivat olla kumpi tahansa pankki JSONissa — tulkitaan dynaamisesti.
function mapEditorToGame(p){
  if(!(p && (p.cols===5) && (p.rows===7))) throw new Error('Väärä koko (vaaditaan 7×5).');
  const toXY = (r,c)=>{
    if(r===0)  return {x:c, y:-1};              // yläpankki
    if(r===6)  return {x:c, y:H};               // alapankki
    return {x:c, y:r-1};                        // vesi → 0..4
  };
  // start/goal
  const s = toXY(p.start.r, p.start.c);
  const g = toXY(p.goal.r,  p.goal.c);
  const start = { side: (s.y===-1 ? 'top':'bottom'), col: s.x };
  const goal  = { side: (g.y===H  ? 'bottom':'top'), col: g.x };

  // tolpat
  const stumps = [];
  const seen = new Set();
  (p.poles||[]).forEach(({r,c})=>{
    const {x,y} = toXY(r,c);
    if(y<0 || y>H) return; // älä lisää pankkien tolppia ruutulistaan
    const k = `${x},${y}`; if(!seen.has(k)){ seen.add(k); stumps.push({x,y}); }
  });

  // lankut (luetaan sellaisenaan, ei automaattitarkastuksia lähtödatasta)
  const planks = [];
  (p.planks||[]).forEach(([r1,c1,r2,c2])=>{
    const a = toXY(r1,c1), b = toXY(r2,c2);
    const dx = b.x - a.x, dy = b.y - a.y;
    if(dx!==0 && dy!==0) return;        // vain suora
    const len = Math.abs(dx)+Math.abs(dy);
    const dir = (dy===0)?'h':'v';
    const x = Math.min(a.x,b.x);
    const y = Math.min(a.y,b.y);
    planks.push({len, x, y, dir});
  });

  return {start, goal, stumps, planks};
}

function applyMappedPuzzle(m){
  state.start = m.start;
  state.goal  = m.goal;
  state.stumps = m.stumps.slice();
  state.planks = m.planks.slice();

  state.hiker = { pos:'bank', row:(state.start.side==='top' ? -1 : H), col: state.start.col };
  state.carrying = 0;
  state.moves = 0;
  state.frozen = false;

  // Tallenna puhdas alkutilanne erilliseen snapshot-muuttujaan
  const cleanInitial = {
    start: state.start,
    goal: state.goal,
    stumps: state.stumps,
    planks: state.planks,
    hiker: state.hiker,
    carrying: 0,
    moves: 0,
    frozen: false
  };
  state._snapshot = JSON.stringify(cleanInitial);  // HUOM: _snapshot, ei snapshot

  render();
}


// ====== Lataa pulmat automaattisesti tiedostosta ======
async function loadPuzzlesFromFile(){
  try{
    const text = await fetch('./puzzles_7x5.json').then(r=>r.text());
    const raw = JSON.parse(text);
    const list = Array.isArray(raw) ? raw : [raw];
    loadedPuzzles = [];
    for(const p of list){
      try{ loadedPuzzles.push( mapEditorToGame(p) ); }
      catch(err){ /* ohita virheellinen */ }
    }
    if(!loadedPuzzles.length){ toast('Tiedostossa ei kelvollisia pulmia'); return; }
    // Täytä valikko
    puzzleSel.innerHTML='';
    loadedPuzzles.forEach((m,i)=>{
      const o=document.createElement('option');
      o.value=String(i);
      o.textContent=`#${i+1} S:${m.start.side==='top'?'Y':'A'}${m.start.col+1} G:${m.goal.side==='bottom'?'A':'Y'}${m.goal.col+1} (planks:${m.planks.length})`;
      puzzleSel.appendChild(o);
    });
    loadedIndex = 0;
    puzzleSel.value = "0";
    applyMappedPuzzle( loadedPuzzles[0] );
  }catch(err){
    console.error(err);
    toast('Pulmien automaattinen lataus epäonnistui');
  }
}

// ====== Nappulat ======
openBtn.addEventListener('click', ()=>{
  const i = +puzzleSel.value;
  if(!(i>=0) || !loadedPuzzles[i]){ toast('Ei valittua pulmaa'); return; }
  loadedIndex = i;
  applyMappedPuzzle( loadedPuzzles[i] );
});
nextBtn.addEventListener('click', ()=>{
  if(!loadedPuzzles.length){ toast('Ei ladattuja pulmia'); return; }
  loadedIndex = (loadedIndex+1+loadedPuzzles.length) % loadedPuzzles.length;
  puzzleSel.value = String(loadedIndex);
  applyMappedPuzzle( loadedPuzzles[loadedIndex] );
});

document.getElementById('reset').addEventListener('click', ()=>{
  const snap = state._snapshot;          // ota talteen ennen Object.assignia
  if(!snap) return;                      // varmistus

  Object.assign(state, JSON.parse(snap)); // palauta alkutilanne
  state._snapshot = snap;                // PIDÄ snapshot tallessa myös seuraavaa kertaa varten
  render();
});

// Ensikäynnistys: lataa puzzles_7x5.json
loadPuzzlesFromFile();
</script>
</body>
</html>
